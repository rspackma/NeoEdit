lexer grammar CSharpLexer;

ABSTRACT   : 'abstract'   ;
ADD        : 'add'        ;
ALIAS      : 'alias'      ;
AS         : 'as'         ;
ASCENDING  : 'ascending'  ;
ASSEMBLY   : 'assembly'   ;
ASYNC      : 'async'      ;
AWAIT      : 'await'      ;
BASE       : 'base'       ;
BREAK      : 'break'      ;
BY         : 'by'         ;
CASE       : 'case'       ;
CATCH      : 'catch'      ;
CHECKED    : 'checked'    ;
CLASS      : 'class'      ;
CONST      : 'const'      ;
CONTINUE   : 'continue'   ;
DEFAULT    : 'default'    ;
DELEGATE   : 'delegate'   ;
DESCENDING : 'descending' ;
DO         : 'do'         ;
ELSE       : 'else'       ;
ENUM       : 'enum'       ;
EQUALS     : 'equals'     ;
EVENT      : 'event'      ;
EXPLICIT   : 'explicit'   ;
EXTERN     : 'extern'     ;
FALSE      : 'false'      ;
FINALLY    : 'finally'    ;
FIXED      : 'fixed'      ;
FOR        : 'for'        ;
FOREACH    : 'foreach'    ;
FROM       : 'from'       ;
GET        : 'get'        ;
GOTO       : 'goto'       ;
GROUP      : 'group'      ;
IF         : 'if'         ;
IMPLICIT   : 'implicit'   ;
IN         : 'in'         ;
INTERFACE  : 'interface'  ;
INTERNAL   : 'internal'   ;
INTO       : 'into'       ;
IS         : 'is'         ;
JOIN       : 'join'       ;
LET        : 'let'        ;
LOCK       : 'lock'       ;
NAMESPACE  : 'namespace'  ;
NEW        : 'new'        ;
NULL       : 'null'       ;
ON         : 'on'         ;
OPERATOR   : 'operator'   ;
ORDERBY    : 'orderby'    ;
OUT        : 'out'        ;
OVERRIDE   : 'override'   ;
PARAMS     : 'params'     ;
PARTIAL    : 'partial'    ;
PRIVATE    : 'private'    ;
PROTECTED  : 'protected'  ;
PUBLIC     : 'public'     ;
READONLY   : 'readonly'   ;
REF        : 'ref'        ;
REMOVE     : 'remove'     ;
RETURN     : 'return'     ;
SEALED     : 'sealed'     ;
SELECT     : 'select'     ;
SET        : 'set'        ;
STACKALLOC : 'stackalloc' ;
STATIC     : 'static'     ;
STRUCT     : 'struct'     ;
SWITCH     : 'switch'     ;
THIS       : 'this'       ;
THROW      : 'throw'      ;
TRUE       : 'true'       ;
TRY        : 'try'        ;
UNCHECKED  : 'unchecked'  ;
UNSAFE     : 'unsafe'     ;
USING      : 'using'      ;
VIRTUAL    : 'virtual'    ;
VOLATILE   : 'volatile'   ;
WHERE      : 'where'      ;
WHILE      : 'while'      ;
YIELD      : 'yield'      ;

PLUS              : '+'   ;
PLUS_ASSIGN       : '+='  ;
AND               : '&'   ;
AND_ASSIGN        : '&='  ;
ASSIGN            : '='   ;
BANG              : '!'   ;
COALESCE          : '??'  ;
COLON             : ':'   ;
COMMA             : ','   ;
DEC               : '--'  ;
DIV               : '/'   ;
DIV_ASSIGN        : '/='  ;
DOT               : '.'   ;
DOUBLE_COLON      : '::'  ;
EQ                : '=='  ;
GE                : '>='  ;
GT                : '>'   ;
INC               : '++'  ;
INTERR            : '?'   ;
LAMBDA            : '=>'  ;
LAND              : '&&'  ;
LBRACE            : '{'   ;
LBRACKET          : '['   ;
LE                : '<='  ;
LEFT_SHIFT        : '<<'  ;
LEFT_SHIFT_ASSIGN : '<<=' ;
LOR               : '||'  ;
LPAREN            : '('   ;
LT                : '<'   ;
MOD               : '%'   ;
MOD_ASSIGN        : '%='  ;
MULT              : '*'   ;
MULT_ASSIGN       : '*='  ;
NE                : '!='  ;
OR                : '|'   ;
OR_ASSIGN         : '|='  ;
PTR               : '->'  ;
RBRACE            : '}'   ;
RBRACKET          : ']'   ;
RPAREN            : ')'   ;
SEMICOLON         : ';'   ;
MINUS             : '-'   ;
MINUS_ASSIGN      : '-='  ;
TILDE             : '~'   ;
XOR               : '^'   ;
XOR_ASSIGN        : '^='  ;

NEWLINE                    : ('\r' | '\n' | '\r' '\n' | '\u0085' | '\u2028' | '\u2029' | EOF) -> skip ;
WHITESPACE                 : ('\u0009' | '\u000b'..'\u000c' | '\u0020' | '\u00a0' | '\u1680' | '\u180e' | '\u2000'..'\u2006' | '\u2008'..'\u200a' | '\u202f' | '\u205f' | '\u3000')+ -> skip ;

COMMENT                    : (SINGLE_COMMENT | DELIMITED_COMMENT) -> skip ;
fragment SINGLE_COMMENT    : '//' ~[\r\n\u0085\u2028\u2029]* ;
fragment DELIMITED_COMMENT : '/*' .*? '*/' ;

IDENTIFIER                 : '@'? IDFIRST IDNEXT* ;
fragment IDFIRST           : '\u0041'..'\u005a'| '\u0061'..'\u007a'| '\u00c0'..'\u00de'| '\u01bb'| '\u01c0'..'\u01c3'| '\u01c5'| '\u01c8'| '\u01cb'| '\u01f2'| '\u0294'| '\u02b0'..'\u02ee'| '\u16ee'..'\u16f0'| '\u2160'..'\u216f'| '\u005f' ;
fragment IDNEXT            : IDFIRST | '\u0030'..'\u0039'| '\u00ad'| '\u0300'..'\u0310'| '\u0600'..'\u0603'| '\u06dd'| '\u0903'| '\u093e'..'\u0940'| '\u0949'..'\u094c'| '\u203f'..'\u2040'| '\u2054'| '\ufe33'..'\ufe34'| '\ufe4d'..'\ufe4f'| '\uff3f' ;

NUMBER                     : (DECIMAL_DIGIT* DOT? DECIMAL_DIGIT+ ([Ee] [-+]? DECIMAL_DIGIT+)? | '0' [Xx] HEX_DIGIT+) [UuLlFfDdMm]* ;
fragment DECIMAL_DIGIT     : '0'..'9' ;
fragment HEX_DIGIT         : '0'..'9' | 'A'..'F' | 'a'..'f' ;

STR                        : REGULAR_STRING | VERBATIM_STRING ;
fragment REGULAR_STRING    : '"' (~["\\\r\n\u0085\u2028\u2029] | ESCAPE)* '"' ;
fragment VERBATIM_STRING   : '@' '"' (~["] | '""')* '"' ;
fragment ESCAPE            : '\\' ~[xUu] | '\\x' HEX_DIGIT+ | '\\u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT | '\\U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT ;

INTERPOLATED_START         : '$"' -> more, pushMode(INTERPOLATED) ;

CHARACTER                  : '\'' (~['\\\r\n\u0085\u2028\u2029] | ESCAPE) '\'' ;

PREPROCESSOR               : '#' (~[\r\n\u0085\u2028\u2029])* NEWLINE -> skip ;

mode INTERPOLATED;
INTERPOLATED_BRACES        : '{{' -> more ;
INTERPOLATED_BRACE         : '{' -> more, pushMode(INTERPOLATED_EXP) ;
INTERPOLATED_CHARS         : (~["{\\\r\n\u0085\u2028\u2029] | ESCAPE)+ -> more ;
INTERPOLATED_STR           : '"' -> popMode ;

mode INTERPOLATED_SUB;
INTERPOLATED_SUB_BRACE     : '{' -> more, pushMode(INTERPOLATED_EXP) ;
INTERPOLATED_SUB_CHARS     : (~["{\\\r\n\u0085\u2028\u2029] | ESCAPE)+ -> more ;
INTERPOLATED_SUB_STRING    : '"' -> more, popMode ;

mode INTERPOLATED_EXP;
INTERPOLATED_EXP_BRACE     : '{' -> more, pushMode(INTERPOLATED_EXP) ;
INTERPOLATED_EXP_CHARS     : (STR | ~["@${}]+) -> more ;
INTERPOLATED_EXP_START     : '$"' -> more, pushMode(INTERPOLATED_SUB) ;
INTERPOLATED_EXP_END       : '}' -> more, popMode;

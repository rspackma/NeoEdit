//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Dev\NeoEdit\Common\Expressions\Source\ExpressionParser.g4 by ANTLR 4.5.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace NeoEdit.Expressions.Parser {
using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.3")]
[System.CLSCompliant(false)]
public partial class ExpressionParser : Parser {
	public const int
		DEBUG=1, LPAREN=2, RPAREN=3, COMMA=4, METHOD=5, BANG=6, EXPOP=7, MULTOP=8, 
		ADDOP=9, SHIFTOP=10, EQUALITYOP=11, RELATIONALOP=12, CONVERSION=13, BITWISENOT=14, 
		BITWISEAND=15, BITWISEXOR=16, BITWISEOR=17, LOGICALAND=18, LOGICALOR=19, 
		NULLCOALESCE=20, CONDITIONAL=21, ELSE=22, DOT=23, CONSTANT=24, STRSTART=25, 
		VSTRSTART=26, ISTRSTART=27, VISTRSTART=28, TRUE=29, FALSE=30, NULL=31, 
		INTEGER=32, FLOAT=33, HEX=34, VARIABLE=35, CURRENCY=36, WHITESPACE=37, 
		ISTRINTEREND=38, STRCHARS=39, STRESCAPE=40, STRUNICODE=41, STREND=42, 
		VSTRCHARS=43, VSTRQUOTE=44, VSTREND=45, ISTRCHARS=46, ISTRLITERAL=47, 
		ISTRINTERSTA=48, ISTREND=49, VISTRCHARS=50, VISTRLITERAL=51, VISTRINTERSTA=52, 
		VISTREND=53;
	public const int
		RULE_expr = 0, RULE_form = 1, RULE_e = 2, RULE_value = 3, RULE_units = 4, 
		RULE_unit = 5, RULE_normalstring = 6, RULE_strcontent = 7, RULE_strchars = 8, 
		RULE_strescape = 9, RULE_strunicode = 10, RULE_verbatimstring = 11, RULE_vstrcontent = 12, 
		RULE_vstrchars = 13, RULE_vstrquote = 14, RULE_interpolatedstring = 15, 
		RULE_istrcontent = 16, RULE_istrchars = 17, RULE_istrliteral = 18, RULE_istrinter = 19, 
		RULE_verbatiminterpolatedstring = 20, RULE_vistrcontent = 21, RULE_vistrchars = 22, 
		RULE_vistrliteral = 23, RULE_vistrinter = 24;
	public static readonly string[] ruleNames = {
		"expr", "form", "e", "value", "units", "unit", "normalstring", "strcontent", 
		"strchars", "strescape", "strunicode", "verbatimstring", "vstrcontent", 
		"vstrchars", "vstrquote", "interpolatedstring", "istrcontent", "istrchars", 
		"istrliteral", "istrinter", "verbatiminterpolatedstring", "vistrcontent", 
		"vistrchars", "vistrliteral", "vistrinter"
	};

	private static readonly string[] _LiteralNames = {
		null, "'#'", "'('", "')'", "','", null, "'!'", "'^'", null, null, null, 
		null, null, "'=>'", "'~'", "'&'", "'^^'", "'|'", "'&&'", "'||'", "'??'", 
		"'?'", "':'", "'.'", null, null, "'@\"'", "'$\"'", null, null, null, null, 
		null, null, null, null, null, null, "'}'", null, null, null, null, null, 
		"'\"\"'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "DEBUG", "LPAREN", "RPAREN", "COMMA", "METHOD", "BANG", "EXPOP", 
		"MULTOP", "ADDOP", "SHIFTOP", "EQUALITYOP", "RELATIONALOP", "CONVERSION", 
		"BITWISENOT", "BITWISEAND", "BITWISEXOR", "BITWISEOR", "LOGICALAND", "LOGICALOR", 
		"NULLCOALESCE", "CONDITIONAL", "ELSE", "DOT", "CONSTANT", "STRSTART", 
		"VSTRSTART", "ISTRSTART", "VISTRSTART", "TRUE", "FALSE", "NULL", "INTEGER", 
		"FLOAT", "HEX", "VARIABLE", "CURRENCY", "WHITESPACE", "ISTRINTEREND", 
		"STRCHARS", "STRESCAPE", "STRUNICODE", "STREND", "VSTRCHARS", "VSTRQUOTE", 
		"VSTREND", "ISTRCHARS", "ISTRLITERAL", "ISTRINTERSTA", "ISTREND", "VISTRCHARS", 
		"VISTRLITERAL", "VISTRINTERSTA", "VISTREND"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "ExpressionParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public ExpressionParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this,_ATN);
	}
	public partial class ExprContext : ParserRuleContext {
		public FormContext form() {
			return GetRuleContext<FormContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(ExpressionParser.Eof, 0); }
		public ITerminalNode DEBUG() { return GetToken(ExpressionParser.DEBUG, 0); }
		public ExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprContext expr() {
		ExprContext _localctx = new ExprContext(Context, State);
		EnterRule(_localctx, 0, RULE_expr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 51;
			_la = TokenStream.La(1);
			if (_la==DEBUG) {
				{
				State = 50; Match(DEBUG);
				}
			}

			State = 53; form();
			State = 54; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FormContext : ParserRuleContext {
		public FormContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_form; } }
	 
		public FormContext() { }
		public virtual void CopyFrom(FormContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ShortFormContext : FormContext {
		public IToken op;
		public ITerminalNode EXPOP() { return GetToken(ExpressionParser.EXPOP, 0); }
		public ITerminalNode MULTOP() { return GetToken(ExpressionParser.MULTOP, 0); }
		public ITerminalNode ADDOP() { return GetToken(ExpressionParser.ADDOP, 0); }
		public ITerminalNode SHIFTOP() { return GetToken(ExpressionParser.SHIFTOP, 0); }
		public ITerminalNode RELATIONALOP() { return GetToken(ExpressionParser.RELATIONALOP, 0); }
		public ITerminalNode EQUALITYOP() { return GetToken(ExpressionParser.EQUALITYOP, 0); }
		public ITerminalNode BITWISEAND() { return GetToken(ExpressionParser.BITWISEAND, 0); }
		public ITerminalNode BITWISEXOR() { return GetToken(ExpressionParser.BITWISEXOR, 0); }
		public ITerminalNode BITWISEOR() { return GetToken(ExpressionParser.BITWISEOR, 0); }
		public ITerminalNode LOGICALAND() { return GetToken(ExpressionParser.LOGICALAND, 0); }
		public ITerminalNode LOGICALOR() { return GetToken(ExpressionParser.LOGICALOR, 0); }
		public ITerminalNode NULLCOALESCE() { return GetToken(ExpressionParser.NULLCOALESCE, 0); }
		public ShortFormContext(FormContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortForm(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DefaultOpFormContext : FormContext {
		public DefaultOpFormContext(FormContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefaultOpForm(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LongFormContext : FormContext {
		public EContext e() {
			return GetRuleContext<EContext>(0);
		}
		public LongFormContext(FormContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLongForm(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FormContext form() {
		FormContext _localctx = new FormContext(Context, State);
		EnterRule(_localctx, 2, RULE_form);
		int _la;
		try {
			State = 59;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
			case 1:
				_localctx = new LongFormContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 56; e(0);
				}
				break;
			case 2:
				_localctx = new ShortFormContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 57;
				((ShortFormContext)_localctx).op = TokenStream.Lt(1);
				_la = TokenStream.La(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EXPOP) | (1L << MULTOP) | (1L << ADDOP) | (1L << SHIFTOP) | (1L << EQUALITYOP) | (1L << RELATIONALOP) | (1L << BITWISEAND) | (1L << BITWISEXOR) | (1L << BITWISEOR) | (1L << LOGICALAND) | (1L << LOGICALOR) | (1L << NULLCOALESCE))) != 0)) ) {
					((ShortFormContext)_localctx).op = ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				}
				break;
			case 3:
				_localctx = new DefaultOpFormContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EContext : ParserRuleContext {
		public EContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_e; } }
	 
		public EContext() { }
		public virtual void CopyFrom(EContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AddContext : EContext {
		public EContext val1;
		public IToken op;
		public EContext val2;
		public EContext[] e() {
			return GetRuleContexts<EContext>();
		}
		public EContext e(int i) {
			return GetRuleContext<EContext>(i);
		}
		public ITerminalNode ADDOP() { return GetToken(ExpressionParser.ADDOP, 0); }
		public AddContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdd(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShiftContext : EContext {
		public EContext val1;
		public IToken op;
		public EContext val2;
		public EContext[] e() {
			return GetRuleContexts<EContext>();
		}
		public EContext e(int i) {
			return GetRuleContext<EContext>(i);
		}
		public ITerminalNode SHIFTOP() { return GetToken(ExpressionParser.SHIFTOP, 0); }
		public ShiftContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShift(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NullCoalesceContext : EContext {
		public EContext val1;
		public IToken op;
		public EContext val2;
		public EContext[] e() {
			return GetRuleContexts<EContext>();
		}
		public EContext e(int i) {
			return GetRuleContext<EContext>(i);
		}
		public ITerminalNode NULLCOALESCE() { return GetToken(ExpressionParser.NULLCOALESCE, 0); }
		public NullCoalesceContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNullCoalesce(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TernaryContext : EContext {
		public EContext condition;
		public EContext trueval;
		public EContext falseval;
		public ITerminalNode CONDITIONAL() { return GetToken(ExpressionParser.CONDITIONAL, 0); }
		public ITerminalNode ELSE() { return GetToken(ExpressionParser.ELSE, 0); }
		public EContext[] e() {
			return GetRuleContexts<EContext>();
		}
		public EContext e(int i) {
			return GetRuleContext<EContext>(i);
		}
		public TernaryContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTernary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParensContext : EContext {
		public EContext val;
		public ITerminalNode LPAREN() { return GetToken(ExpressionParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(ExpressionParser.RPAREN, 0); }
		public EContext e() {
			return GetRuleContext<EContext>(0);
		}
		public ParensContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParens(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConstantContext : EContext {
		public IToken constant;
		public ITerminalNode CONSTANT() { return GetToken(ExpressionParser.CONSTANT, 0); }
		public ConstantContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstant(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DotContext : EContext {
		public EContext val1;
		public IToken op;
		public EContext val2;
		public EContext[] e() {
			return GetRuleContexts<EContext>();
		}
		public EContext e(int i) {
			return GetRuleContext<EContext>(i);
		}
		public ITerminalNode DOT() { return GetToken(ExpressionParser.DOT, 0); }
		public DotContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDot(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RelationalContext : EContext {
		public EContext val1;
		public IToken op;
		public EContext val2;
		public EContext[] e() {
			return GetRuleContexts<EContext>();
		}
		public EContext e(int i) {
			return GetRuleContext<EContext>(i);
		}
		public ITerminalNode RELATIONALOP() { return GetToken(ExpressionParser.RELATIONALOP, 0); }
		public RelationalContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelational(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MethodContext : EContext {
		public IToken method;
		public ITerminalNode LPAREN() { return GetToken(ExpressionParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(ExpressionParser.RPAREN, 0); }
		public ITerminalNode METHOD() { return GetToken(ExpressionParser.METHOD, 0); }
		public EContext[] e() {
			return GetRuleContexts<EContext>();
		}
		public EContext e(int i) {
			return GetRuleContext<EContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(ExpressionParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(ExpressionParser.COMMA, i);
		}
		public MethodContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMethod(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnaryContext : EContext {
		public IToken op;
		public EContext val;
		public EContext e() {
			return GetRuleContext<EContext>(0);
		}
		public ITerminalNode BITWISENOT() { return GetToken(ExpressionParser.BITWISENOT, 0); }
		public ITerminalNode ADDOP() { return GetToken(ExpressionParser.ADDOP, 0); }
		public ITerminalNode BANG() { return GetToken(ExpressionParser.BANG, 0); }
		public UnaryContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalOrContext : EContext {
		public EContext val1;
		public IToken op;
		public EContext val2;
		public EContext[] e() {
			return GetRuleContexts<EContext>();
		}
		public EContext e(int i) {
			return GetRuleContext<EContext>(i);
		}
		public ITerminalNode LOGICALOR() { return GetToken(ExpressionParser.LOGICALOR, 0); }
		public LogicalOrContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalOr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SimpleContext : EContext {
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public SimpleContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimple(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AddUnitsContext : EContext {
		public EContext val1;
		public UnitsContext unitsVal;
		public EContext e() {
			return GetRuleContext<EContext>(0);
		}
		public UnitsContext units() {
			return GetRuleContext<UnitsContext>(0);
		}
		public AddUnitsContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddUnits(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnitConversionContext : EContext {
		public EContext val1;
		public IToken op;
		public UnitsContext val2;
		public EContext e() {
			return GetRuleContext<EContext>(0);
		}
		public ITerminalNode CONVERSION() { return GetToken(ExpressionParser.CONVERSION, 0); }
		public UnitsContext units() {
			return GetRuleContext<UnitsContext>(0);
		}
		public UnitConversionContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnitConversion(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MultContext : EContext {
		public EContext val1;
		public IToken op;
		public EContext val2;
		public EContext[] e() {
			return GetRuleContexts<EContext>();
		}
		public EContext e(int i) {
			return GetRuleContext<EContext>(i);
		}
		public ITerminalNode MULTOP() { return GetToken(ExpressionParser.MULTOP, 0); }
		public MultContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMult(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BitwiseXorContext : EContext {
		public EContext val1;
		public IToken op;
		public EContext val2;
		public EContext[] e() {
			return GetRuleContexts<EContext>();
		}
		public EContext e(int i) {
			return GetRuleContext<EContext>(i);
		}
		public ITerminalNode BITWISEXOR() { return GetToken(ExpressionParser.BITWISEXOR, 0); }
		public BitwiseXorContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitwiseXor(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BitwiseOrContext : EContext {
		public EContext val1;
		public IToken op;
		public EContext val2;
		public EContext[] e() {
			return GetRuleContexts<EContext>();
		}
		public EContext e(int i) {
			return GetRuleContext<EContext>(i);
		}
		public ITerminalNode BITWISEOR() { return GetToken(ExpressionParser.BITWISEOR, 0); }
		public BitwiseOrContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitwiseOr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicalAndContext : EContext {
		public EContext val1;
		public IToken op;
		public EContext val2;
		public EContext[] e() {
			return GetRuleContexts<EContext>();
		}
		public EContext e(int i) {
			return GetRuleContext<EContext>(i);
		}
		public ITerminalNode LOGICALAND() { return GetToken(ExpressionParser.LOGICALAND, 0); }
		public LogicalAndContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicalAnd(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BitwiseAndContext : EContext {
		public EContext val1;
		public IToken op;
		public EContext val2;
		public EContext[] e() {
			return GetRuleContexts<EContext>();
		}
		public EContext e(int i) {
			return GetRuleContext<EContext>(i);
		}
		public ITerminalNode BITWISEAND() { return GetToken(ExpressionParser.BITWISEAND, 0); }
		public BitwiseAndContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitwiseAnd(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnaryEndContext : EContext {
		public ValueContext val;
		public IToken op;
		public ValueContext value() {
			return GetRuleContext<ValueContext>(0);
		}
		public ITerminalNode BANG() { return GetToken(ExpressionParser.BANG, 0); }
		public UnaryEndContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryEnd(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class EqualityContext : EContext {
		public EContext val1;
		public IToken op;
		public EContext val2;
		public EContext[] e() {
			return GetRuleContexts<EContext>();
		}
		public EContext e(int i) {
			return GetRuleContext<EContext>(i);
		}
		public ITerminalNode EQUALITYOP() { return GetToken(ExpressionParser.EQUALITYOP, 0); }
		public EqualityContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEquality(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpContext : EContext {
		public EContext val1;
		public IToken op;
		public EContext val2;
		public EContext[] e() {
			return GetRuleContexts<EContext>();
		}
		public EContext e(int i) {
			return GetRuleContext<EContext>(i);
		}
		public ITerminalNode EXPOP() { return GetToken(ExpressionParser.EXPOP, 0); }
		public ExpContext(EContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EContext e() {
		return e(0);
	}

	private EContext e(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		EContext _localctx = new EContext(Context, _parentState);
		EContext _prevctx = _localctx;
		int _startState = 4;
		EnterRecursionRule(_localctx, 4, RULE_e, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 86;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				_localctx = new MethodContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 62; ((MethodContext)_localctx).method = Match(METHOD);
				State = 63; Match(LPAREN);
				State = 72;
				_la = TokenStream.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LPAREN) | (1L << METHOD) | (1L << BANG) | (1L << ADDOP) | (1L << BITWISENOT) | (1L << CONSTANT) | (1L << STRSTART) | (1L << VSTRSTART) | (1L << ISTRSTART) | (1L << VISTRSTART) | (1L << TRUE) | (1L << FALSE) | (1L << NULL) | (1L << INTEGER) | (1L << FLOAT) | (1L << HEX) | (1L << VARIABLE))) != 0)) {
					{
					State = 64; e(0);
					State = 69;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
					while (_la==COMMA) {
						{
						{
						State = 65; Match(COMMA);
						State = 66; e(0);
						}
						}
						State = 71;
						ErrorHandler.Sync(this);
						_la = TokenStream.La(1);
					}
					}
				}

				State = 74; Match(RPAREN);
				}
				break;
			case 2:
				{
				_localctx = new ParensContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 75; Match(LPAREN);
				State = 76; ((ParensContext)_localctx).val = e(0);
				State = 77; Match(RPAREN);
				}
				break;
			case 3:
				{
				_localctx = new UnaryContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 79;
				((UnaryContext)_localctx).op = TokenStream.Lt(1);
				_la = TokenStream.La(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << BANG) | (1L << ADDOP) | (1L << BITWISENOT))) != 0)) ) {
					((UnaryContext)_localctx).op = ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 80; ((UnaryContext)_localctx).val = e(18);
				}
				break;
			case 4:
				{
				_localctx = new UnaryEndContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 81; ((UnaryEndContext)_localctx).val = value();
				State = 82; ((UnaryEndContext)_localctx).op = Match(BANG);
				}
				break;
			case 5:
				{
				_localctx = new ConstantContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 84; ((ConstantContext)_localctx).constant = Match(CONSTANT);
				}
				break;
			case 6:
				{
				_localctx = new SimpleContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 85; value();
				}
				break;
			}
			Context.Stop = TokenStream.Lt(-1);
			State = 140;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,6,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 138;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
					case 1:
						{
						_localctx = new DotContext(new EContext(_parentctx, _parentState));
						((DotContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 88;
						if (!(Precpred(Context, 19))) throw new FailedPredicateException(this, "Precpred(Context, 19)");
						State = 89; ((DotContext)_localctx).op = Match(DOT);
						State = 90; ((DotContext)_localctx).val2 = e(20);
						}
						break;
					case 2:
						{
						_localctx = new ExpContext(new EContext(_parentctx, _parentState));
						((ExpContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 91;
						if (!(Precpred(Context, 16))) throw new FailedPredicateException(this, "Precpred(Context, 16)");
						State = 92; ((ExpContext)_localctx).op = Match(EXPOP);
						State = 93; ((ExpContext)_localctx).val2 = e(17);
						}
						break;
					case 3:
						{
						_localctx = new MultContext(new EContext(_parentctx, _parentState));
						((MultContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 94;
						if (!(Precpred(Context, 15))) throw new FailedPredicateException(this, "Precpred(Context, 15)");
						State = 95; ((MultContext)_localctx).op = Match(MULTOP);
						State = 96; ((MultContext)_localctx).val2 = e(16);
						}
						break;
					case 4:
						{
						_localctx = new AddContext(new EContext(_parentctx, _parentState));
						((AddContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 97;
						if (!(Precpred(Context, 14))) throw new FailedPredicateException(this, "Precpred(Context, 14)");
						State = 98; ((AddContext)_localctx).op = Match(ADDOP);
						State = 99; ((AddContext)_localctx).val2 = e(15);
						}
						break;
					case 5:
						{
						_localctx = new ShiftContext(new EContext(_parentctx, _parentState));
						((ShiftContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 100;
						if (!(Precpred(Context, 13))) throw new FailedPredicateException(this, "Precpred(Context, 13)");
						State = 101; ((ShiftContext)_localctx).op = Match(SHIFTOP);
						State = 102; ((ShiftContext)_localctx).val2 = e(14);
						}
						break;
					case 6:
						{
						_localctx = new RelationalContext(new EContext(_parentctx, _parentState));
						((RelationalContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 103;
						if (!(Precpred(Context, 12))) throw new FailedPredicateException(this, "Precpred(Context, 12)");
						State = 104; ((RelationalContext)_localctx).op = Match(RELATIONALOP);
						State = 105; ((RelationalContext)_localctx).val2 = e(13);
						}
						break;
					case 7:
						{
						_localctx = new EqualityContext(new EContext(_parentctx, _parentState));
						((EqualityContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 106;
						if (!(Precpred(Context, 11))) throw new FailedPredicateException(this, "Precpred(Context, 11)");
						State = 107; ((EqualityContext)_localctx).op = Match(EQUALITYOP);
						State = 108; ((EqualityContext)_localctx).val2 = e(12);
						}
						break;
					case 8:
						{
						_localctx = new BitwiseAndContext(new EContext(_parentctx, _parentState));
						((BitwiseAndContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 109;
						if (!(Precpred(Context, 10))) throw new FailedPredicateException(this, "Precpred(Context, 10)");
						State = 110; ((BitwiseAndContext)_localctx).op = Match(BITWISEAND);
						State = 111; ((BitwiseAndContext)_localctx).val2 = e(11);
						}
						break;
					case 9:
						{
						_localctx = new BitwiseXorContext(new EContext(_parentctx, _parentState));
						((BitwiseXorContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 112;
						if (!(Precpred(Context, 9))) throw new FailedPredicateException(this, "Precpred(Context, 9)");
						State = 113; ((BitwiseXorContext)_localctx).op = Match(BITWISEXOR);
						State = 114; ((BitwiseXorContext)_localctx).val2 = e(10);
						}
						break;
					case 10:
						{
						_localctx = new BitwiseOrContext(new EContext(_parentctx, _parentState));
						((BitwiseOrContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 115;
						if (!(Precpred(Context, 8))) throw new FailedPredicateException(this, "Precpred(Context, 8)");
						State = 116; ((BitwiseOrContext)_localctx).op = Match(BITWISEOR);
						State = 117; ((BitwiseOrContext)_localctx).val2 = e(9);
						}
						break;
					case 11:
						{
						_localctx = new LogicalAndContext(new EContext(_parentctx, _parentState));
						((LogicalAndContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 118;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 119; ((LogicalAndContext)_localctx).op = Match(LOGICALAND);
						State = 120; ((LogicalAndContext)_localctx).val2 = e(8);
						}
						break;
					case 12:
						{
						_localctx = new LogicalOrContext(new EContext(_parentctx, _parentState));
						((LogicalOrContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 121;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 122; ((LogicalOrContext)_localctx).op = Match(LOGICALOR);
						State = 123; ((LogicalOrContext)_localctx).val2 = e(7);
						}
						break;
					case 13:
						{
						_localctx = new NullCoalesceContext(new EContext(_parentctx, _parentState));
						((NullCoalesceContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 124;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 125; ((NullCoalesceContext)_localctx).op = Match(NULLCOALESCE);
						State = 126; ((NullCoalesceContext)_localctx).val2 = e(6);
						}
						break;
					case 14:
						{
						_localctx = new TernaryContext(new EContext(_parentctx, _parentState));
						((TernaryContext)_localctx).condition = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 127;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 128; Match(CONDITIONAL);
						State = 129; ((TernaryContext)_localctx).trueval = e(0);
						State = 130; Match(ELSE);
						State = 131; ((TernaryContext)_localctx).falseval = e(4);
						}
						break;
					case 15:
						{
						_localctx = new AddUnitsContext(new EContext(_parentctx, _parentState));
						((AddUnitsContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 133;
						if (!(Precpred(Context, 20))) throw new FailedPredicateException(this, "Precpred(Context, 20)");
						State = 134; ((AddUnitsContext)_localctx).unitsVal = units(0);
						}
						break;
					case 16:
						{
						_localctx = new UnitConversionContext(new EContext(_parentctx, _parentState));
						((UnitConversionContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_e);
						State = 135;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 136; ((UnitConversionContext)_localctx).op = Match(CONVERSION);
						State = 137; ((UnitConversionContext)_localctx).val2 = units(0);
						}
						break;
					}
					} 
				}
				State = 142;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,6,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ValueContext : ParserRuleContext {
		public ValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_value; } }
	 
		public ValueContext() { }
		public virtual void CopyFrom(ValueContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IntegerContext : ValueContext {
		public IToken val;
		public ITerminalNode INTEGER() { return GetToken(ExpressionParser.INTEGER, 0); }
		public IntegerContext(ValueContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInteger(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FloatContext : ValueContext {
		public IToken val;
		public ITerminalNode FLOAT() { return GetToken(ExpressionParser.FLOAT, 0); }
		public FloatContext(ValueContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFloat(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NullContext : ValueContext {
		public ITerminalNode NULL() { return GetToken(ExpressionParser.NULL, 0); }
		public NullContext(ValueContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNull(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VariableContext : ValueContext {
		public IToken val;
		public ITerminalNode VARIABLE() { return GetToken(ExpressionParser.VARIABLE, 0); }
		public VariableContext(ValueContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariable(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TrueContext : ValueContext {
		public ITerminalNode TRUE() { return GetToken(ExpressionParser.TRUE, 0); }
		public TrueContext(ValueContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrue(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class HexContext : ValueContext {
		public IToken val;
		public ITerminalNode HEX() { return GetToken(ExpressionParser.HEX, 0); }
		public HexContext(ValueContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHex(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StringContext : ValueContext {
		public NormalstringContext normalstring() {
			return GetRuleContext<NormalstringContext>(0);
		}
		public VerbatimstringContext verbatimstring() {
			return GetRuleContext<VerbatimstringContext>(0);
		}
		public InterpolatedstringContext interpolatedstring() {
			return GetRuleContext<InterpolatedstringContext>(0);
		}
		public VerbatiminterpolatedstringContext verbatiminterpolatedstring() {
			return GetRuleContext<VerbatiminterpolatedstringContext>(0);
		}
		public StringContext(ValueContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitString(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FalseContext : ValueContext {
		public ITerminalNode FALSE() { return GetToken(ExpressionParser.FALSE, 0); }
		public FalseContext(ValueContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFalse(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ValueContext value() {
		ValueContext _localctx = new ValueContext(Context, State);
		EnterRule(_localctx, 6, RULE_value);
		try {
			State = 156;
			switch (TokenStream.La(1)) {
			case STRSTART:
			case VSTRSTART:
			case ISTRSTART:
			case VISTRSTART:
				_localctx = new StringContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 147;
				switch (TokenStream.La(1)) {
				case STRSTART:
					{
					State = 143; normalstring();
					}
					break;
				case VSTRSTART:
					{
					State = 144; verbatimstring();
					}
					break;
				case ISTRSTART:
					{
					State = 145; interpolatedstring();
					}
					break;
				case VISTRSTART:
					{
					State = 146; verbatiminterpolatedstring();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case TRUE:
				_localctx = new TrueContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 149; Match(TRUE);
				}
				break;
			case FALSE:
				_localctx = new FalseContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 150; Match(FALSE);
				}
				break;
			case NULL:
				_localctx = new NullContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 151; Match(NULL);
				}
				break;
			case INTEGER:
				_localctx = new IntegerContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 152; ((IntegerContext)_localctx).val = Match(INTEGER);
				}
				break;
			case FLOAT:
				_localctx = new FloatContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 153; ((FloatContext)_localctx).val = Match(FLOAT);
				}
				break;
			case HEX:
				_localctx = new HexContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 154; ((HexContext)_localctx).val = Match(HEX);
				}
				break;
			case VARIABLE:
				_localctx = new VariableContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 155; ((VariableContext)_localctx).val = Match(VARIABLE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnitsContext : ParserRuleContext {
		public UnitsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_units; } }
	 
		public UnitsContext() { }
		public virtual void CopyFrom(UnitsContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class UnitMultContext : UnitsContext {
		public UnitsContext val1;
		public IToken op;
		public UnitsContext val2;
		public UnitsContext[] units() {
			return GetRuleContexts<UnitsContext>();
		}
		public UnitsContext units(int i) {
			return GetRuleContext<UnitsContext>(i);
		}
		public ITerminalNode MULTOP() { return GetToken(ExpressionParser.MULTOP, 0); }
		public UnitMultContext(UnitsContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnitMult(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnitSimpleContext : UnitsContext {
		public UnitContext unit() {
			return GetRuleContext<UnitContext>(0);
		}
		public UnitSimpleContext(UnitsContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnitSimple(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnitParenContext : UnitsContext {
		public ITerminalNode LPAREN() { return GetToken(ExpressionParser.LPAREN, 0); }
		public UnitsContext units() {
			return GetRuleContext<UnitsContext>(0);
		}
		public ITerminalNode RPAREN() { return GetToken(ExpressionParser.RPAREN, 0); }
		public UnitParenContext(UnitsContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnitParen(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnitExpContext : UnitsContext {
		public UnitsContext base1;
		public IToken op;
		public IToken power;
		public UnitsContext units() {
			return GetRuleContext<UnitsContext>(0);
		}
		public ITerminalNode EXPOP() { return GetToken(ExpressionParser.EXPOP, 0); }
		public ITerminalNode INTEGER() { return GetToken(ExpressionParser.INTEGER, 0); }
		public UnitExpContext(UnitsContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnitExp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnitsContext units() {
		return units(0);
	}

	private UnitsContext units(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		UnitsContext _localctx = new UnitsContext(Context, _parentState);
		UnitsContext _prevctx = _localctx;
		int _startState = 8;
		EnterRecursionRule(_localctx, 8, RULE_units, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 164;
			switch (TokenStream.La(1)) {
			case LPAREN:
				{
				_localctx = new UnitParenContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 159; Match(LPAREN);
				State = 160; units(0);
				State = 161; Match(RPAREN);
				}
				break;
			case METHOD:
			case CONSTANT:
			case TRUE:
			case FALSE:
			case NULL:
			case VARIABLE:
			case CURRENCY:
				{
				_localctx = new UnitSimpleContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 163; unit();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.Lt(-1);
			State = 174;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 172;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
					case 1:
						{
						_localctx = new UnitMultContext(new UnitsContext(_parentctx, _parentState));
						((UnitMultContext)_localctx).val1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_units);
						State = 166;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 167; ((UnitMultContext)_localctx).op = Match(MULTOP);
						State = 168; ((UnitMultContext)_localctx).val2 = units(4);
						}
						break;
					case 2:
						{
						_localctx = new UnitExpContext(new UnitsContext(_parentctx, _parentState));
						((UnitExpContext)_localctx).base1 = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_units);
						State = 169;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 170; ((UnitExpContext)_localctx).op = Match(EXPOP);
						State = 171; ((UnitExpContext)_localctx).power = Match(INTEGER);
						}
						break;
					}
					} 
				}
				State = 176;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class UnitContext : ParserRuleContext {
		public IToken val;
		public ITerminalNode CONSTANT() { return GetToken(ExpressionParser.CONSTANT, 0); }
		public ITerminalNode FALSE() { return GetToken(ExpressionParser.FALSE, 0); }
		public ITerminalNode METHOD() { return GetToken(ExpressionParser.METHOD, 0); }
		public ITerminalNode NULL() { return GetToken(ExpressionParser.NULL, 0); }
		public ITerminalNode TRUE() { return GetToken(ExpressionParser.TRUE, 0); }
		public ITerminalNode VARIABLE() { return GetToken(ExpressionParser.VARIABLE, 0); }
		public ITerminalNode CURRENCY() { return GetToken(ExpressionParser.CURRENCY, 0); }
		public UnitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unit; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnitContext unit() {
		UnitContext _localctx = new UnitContext(Context, State);
		EnterRule(_localctx, 10, RULE_unit);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 177;
			_localctx.val = TokenStream.Lt(1);
			_la = TokenStream.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << METHOD) | (1L << CONSTANT) | (1L << TRUE) | (1L << FALSE) | (1L << NULL) | (1L << VARIABLE) | (1L << CURRENCY))) != 0)) ) {
				_localctx.val = ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NormalstringContext : ParserRuleContext {
		public StrcontentContext val;
		public ITerminalNode STRSTART() { return GetToken(ExpressionParser.STRSTART, 0); }
		public ITerminalNode STREND() { return GetToken(ExpressionParser.STREND, 0); }
		public StrcontentContext strcontent() {
			return GetRuleContext<StrcontentContext>(0);
		}
		public NormalstringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_normalstring; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNormalstring(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NormalstringContext normalstring() {
		NormalstringContext _localctx = new NormalstringContext(Context, State);
		EnterRule(_localctx, 12, RULE_normalstring);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 179; Match(STRSTART);
			State = 180; _localctx.val = strcontent();
			State = 181; Match(STREND);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StrcontentContext : ParserRuleContext {
		public StrcharsContext[] strchars() {
			return GetRuleContexts<StrcharsContext>();
		}
		public StrcharsContext strchars(int i) {
			return GetRuleContext<StrcharsContext>(i);
		}
		public StrescapeContext[] strescape() {
			return GetRuleContexts<StrescapeContext>();
		}
		public StrescapeContext strescape(int i) {
			return GetRuleContext<StrescapeContext>(i);
		}
		public StrunicodeContext[] strunicode() {
			return GetRuleContexts<StrunicodeContext>();
		}
		public StrunicodeContext strunicode(int i) {
			return GetRuleContext<StrunicodeContext>(i);
		}
		public StrcontentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_strcontent; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStrcontent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StrcontentContext strcontent() {
		StrcontentContext _localctx = new StrcontentContext(Context, State);
		EnterRule(_localctx, 14, RULE_strcontent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 188;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << STRCHARS) | (1L << STRESCAPE) | (1L << STRUNICODE))) != 0)) {
				{
				State = 186;
				switch (TokenStream.La(1)) {
				case STRCHARS:
					{
					State = 183; strchars();
					}
					break;
				case STRESCAPE:
					{
					State = 184; strescape();
					}
					break;
				case STRUNICODE:
					{
					State = 185; strunicode();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 190;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StrcharsContext : ParserRuleContext {
		public IToken val;
		public ITerminalNode STRCHARS() { return GetToken(ExpressionParser.STRCHARS, 0); }
		public StrcharsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_strchars; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStrchars(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StrcharsContext strchars() {
		StrcharsContext _localctx = new StrcharsContext(Context, State);
		EnterRule(_localctx, 16, RULE_strchars);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 191; _localctx.val = Match(STRCHARS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StrescapeContext : ParserRuleContext {
		public IToken val;
		public ITerminalNode STRESCAPE() { return GetToken(ExpressionParser.STRESCAPE, 0); }
		public StrescapeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_strescape; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStrescape(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StrescapeContext strescape() {
		StrescapeContext _localctx = new StrescapeContext(Context, State);
		EnterRule(_localctx, 18, RULE_strescape);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 193; _localctx.val = Match(STRESCAPE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StrunicodeContext : ParserRuleContext {
		public IToken val;
		public ITerminalNode STRUNICODE() { return GetToken(ExpressionParser.STRUNICODE, 0); }
		public StrunicodeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_strunicode; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStrunicode(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StrunicodeContext strunicode() {
		StrunicodeContext _localctx = new StrunicodeContext(Context, State);
		EnterRule(_localctx, 20, RULE_strunicode);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 195; _localctx.val = Match(STRUNICODE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VerbatimstringContext : ParserRuleContext {
		public VstrcontentContext val;
		public ITerminalNode VSTRSTART() { return GetToken(ExpressionParser.VSTRSTART, 0); }
		public ITerminalNode VSTREND() { return GetToken(ExpressionParser.VSTREND, 0); }
		public VstrcontentContext vstrcontent() {
			return GetRuleContext<VstrcontentContext>(0);
		}
		public VerbatimstringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_verbatimstring; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVerbatimstring(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VerbatimstringContext verbatimstring() {
		VerbatimstringContext _localctx = new VerbatimstringContext(Context, State);
		EnterRule(_localctx, 22, RULE_verbatimstring);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 197; Match(VSTRSTART);
			State = 198; _localctx.val = vstrcontent();
			State = 199; Match(VSTREND);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VstrcontentContext : ParserRuleContext {
		public VstrcharsContext[] vstrchars() {
			return GetRuleContexts<VstrcharsContext>();
		}
		public VstrcharsContext vstrchars(int i) {
			return GetRuleContext<VstrcharsContext>(i);
		}
		public VstrquoteContext[] vstrquote() {
			return GetRuleContexts<VstrquoteContext>();
		}
		public VstrquoteContext vstrquote(int i) {
			return GetRuleContext<VstrquoteContext>(i);
		}
		public VstrcontentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vstrcontent; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVstrcontent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VstrcontentContext vstrcontent() {
		VstrcontentContext _localctx = new VstrcontentContext(Context, State);
		EnterRule(_localctx, 24, RULE_vstrcontent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 205;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==VSTRCHARS || _la==VSTRQUOTE) {
				{
				State = 203;
				switch (TokenStream.La(1)) {
				case VSTRCHARS:
					{
					State = 201; vstrchars();
					}
					break;
				case VSTRQUOTE:
					{
					State = 202; vstrquote();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 207;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VstrcharsContext : ParserRuleContext {
		public IToken val;
		public ITerminalNode VSTRCHARS() { return GetToken(ExpressionParser.VSTRCHARS, 0); }
		public VstrcharsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vstrchars; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVstrchars(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VstrcharsContext vstrchars() {
		VstrcharsContext _localctx = new VstrcharsContext(Context, State);
		EnterRule(_localctx, 26, RULE_vstrchars);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 208; _localctx.val = Match(VSTRCHARS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VstrquoteContext : ParserRuleContext {
		public ITerminalNode VSTRQUOTE() { return GetToken(ExpressionParser.VSTRQUOTE, 0); }
		public VstrquoteContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vstrquote; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVstrquote(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VstrquoteContext vstrquote() {
		VstrquoteContext _localctx = new VstrquoteContext(Context, State);
		EnterRule(_localctx, 28, RULE_vstrquote);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 210; Match(VSTRQUOTE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InterpolatedstringContext : ParserRuleContext {
		public IstrcontentContext val;
		public ITerminalNode ISTRSTART() { return GetToken(ExpressionParser.ISTRSTART, 0); }
		public ITerminalNode ISTREND() { return GetToken(ExpressionParser.ISTREND, 0); }
		public IstrcontentContext istrcontent() {
			return GetRuleContext<IstrcontentContext>(0);
		}
		public InterpolatedstringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_interpolatedstring; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInterpolatedstring(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InterpolatedstringContext interpolatedstring() {
		InterpolatedstringContext _localctx = new InterpolatedstringContext(Context, State);
		EnterRule(_localctx, 30, RULE_interpolatedstring);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 212; Match(ISTRSTART);
			State = 213; _localctx.val = istrcontent();
			State = 214; Match(ISTREND);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IstrcontentContext : ParserRuleContext {
		public IstrcharsContext[] istrchars() {
			return GetRuleContexts<IstrcharsContext>();
		}
		public IstrcharsContext istrchars(int i) {
			return GetRuleContext<IstrcharsContext>(i);
		}
		public StrescapeContext[] strescape() {
			return GetRuleContexts<StrescapeContext>();
		}
		public StrescapeContext strescape(int i) {
			return GetRuleContext<StrescapeContext>(i);
		}
		public StrunicodeContext[] strunicode() {
			return GetRuleContexts<StrunicodeContext>();
		}
		public StrunicodeContext strunicode(int i) {
			return GetRuleContext<StrunicodeContext>(i);
		}
		public IstrliteralContext[] istrliteral() {
			return GetRuleContexts<IstrliteralContext>();
		}
		public IstrliteralContext istrliteral(int i) {
			return GetRuleContext<IstrliteralContext>(i);
		}
		public IstrinterContext[] istrinter() {
			return GetRuleContexts<IstrinterContext>();
		}
		public IstrinterContext istrinter(int i) {
			return GetRuleContext<IstrinterContext>(i);
		}
		public IstrcontentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_istrcontent; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIstrcontent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IstrcontentContext istrcontent() {
		IstrcontentContext _localctx = new IstrcontentContext(Context, State);
		EnterRule(_localctx, 32, RULE_istrcontent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 223;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << STRESCAPE) | (1L << STRUNICODE) | (1L << ISTRCHARS) | (1L << ISTRLITERAL) | (1L << ISTRINTERSTA))) != 0)) {
				{
				State = 221;
				switch (TokenStream.La(1)) {
				case ISTRCHARS:
					{
					State = 216; istrchars();
					}
					break;
				case STRESCAPE:
					{
					State = 217; strescape();
					}
					break;
				case STRUNICODE:
					{
					State = 218; strunicode();
					}
					break;
				case ISTRLITERAL:
					{
					State = 219; istrliteral();
					}
					break;
				case ISTRINTERSTA:
					{
					State = 220; istrinter();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 225;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IstrcharsContext : ParserRuleContext {
		public IToken val;
		public ITerminalNode ISTRCHARS() { return GetToken(ExpressionParser.ISTRCHARS, 0); }
		public IstrcharsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_istrchars; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIstrchars(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IstrcharsContext istrchars() {
		IstrcharsContext _localctx = new IstrcharsContext(Context, State);
		EnterRule(_localctx, 34, RULE_istrchars);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 226; _localctx.val = Match(ISTRCHARS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IstrliteralContext : ParserRuleContext {
		public IToken val;
		public ITerminalNode ISTRLITERAL() { return GetToken(ExpressionParser.ISTRLITERAL, 0); }
		public IstrliteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_istrliteral; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIstrliteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IstrliteralContext istrliteral() {
		IstrliteralContext _localctx = new IstrliteralContext(Context, State);
		EnterRule(_localctx, 36, RULE_istrliteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 228; _localctx.val = Match(ISTRLITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IstrinterContext : ParserRuleContext {
		public EContext val;
		public ITerminalNode ISTRINTERSTA() { return GetToken(ExpressionParser.ISTRINTERSTA, 0); }
		public ITerminalNode ISTRINTEREND() { return GetToken(ExpressionParser.ISTRINTEREND, 0); }
		public EContext e() {
			return GetRuleContext<EContext>(0);
		}
		public IstrinterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_istrinter; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIstrinter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IstrinterContext istrinter() {
		IstrinterContext _localctx = new IstrinterContext(Context, State);
		EnterRule(_localctx, 38, RULE_istrinter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 230; Match(ISTRINTERSTA);
			State = 231; _localctx.val = e(0);
			State = 232; Match(ISTRINTEREND);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VerbatiminterpolatedstringContext : ParserRuleContext {
		public VistrcontentContext val;
		public ITerminalNode VISTRSTART() { return GetToken(ExpressionParser.VISTRSTART, 0); }
		public ITerminalNode VISTREND() { return GetToken(ExpressionParser.VISTREND, 0); }
		public VistrcontentContext vistrcontent() {
			return GetRuleContext<VistrcontentContext>(0);
		}
		public VerbatiminterpolatedstringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_verbatiminterpolatedstring; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVerbatiminterpolatedstring(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VerbatiminterpolatedstringContext verbatiminterpolatedstring() {
		VerbatiminterpolatedstringContext _localctx = new VerbatiminterpolatedstringContext(Context, State);
		EnterRule(_localctx, 40, RULE_verbatiminterpolatedstring);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 234; Match(VISTRSTART);
			State = 235; _localctx.val = vistrcontent();
			State = 236; Match(VISTREND);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VistrcontentContext : ParserRuleContext {
		public VistrcharsContext[] vistrchars() {
			return GetRuleContexts<VistrcharsContext>();
		}
		public VistrcharsContext vistrchars(int i) {
			return GetRuleContext<VistrcharsContext>(i);
		}
		public VistrliteralContext[] vistrliteral() {
			return GetRuleContexts<VistrliteralContext>();
		}
		public VistrliteralContext vistrliteral(int i) {
			return GetRuleContext<VistrliteralContext>(i);
		}
		public VistrinterContext[] vistrinter() {
			return GetRuleContexts<VistrinterContext>();
		}
		public VistrinterContext vistrinter(int i) {
			return GetRuleContext<VistrinterContext>(i);
		}
		public VistrcontentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vistrcontent; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVistrcontent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VistrcontentContext vistrcontent() {
		VistrcontentContext _localctx = new VistrcontentContext(Context, State);
		EnterRule(_localctx, 42, RULE_vistrcontent);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 243;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << VISTRCHARS) | (1L << VISTRLITERAL) | (1L << VISTRINTERSTA))) != 0)) {
				{
				State = 241;
				switch (TokenStream.La(1)) {
				case VISTRCHARS:
					{
					State = 238; vistrchars();
					}
					break;
				case VISTRLITERAL:
					{
					State = 239; vistrliteral();
					}
					break;
				case VISTRINTERSTA:
					{
					State = 240; vistrinter();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 245;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VistrcharsContext : ParserRuleContext {
		public IToken val;
		public ITerminalNode VISTRCHARS() { return GetToken(ExpressionParser.VISTRCHARS, 0); }
		public VistrcharsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vistrchars; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVistrchars(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VistrcharsContext vistrchars() {
		VistrcharsContext _localctx = new VistrcharsContext(Context, State);
		EnterRule(_localctx, 44, RULE_vistrchars);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 246; _localctx.val = Match(VISTRCHARS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VistrliteralContext : ParserRuleContext {
		public IToken val;
		public ITerminalNode VISTRLITERAL() { return GetToken(ExpressionParser.VISTRLITERAL, 0); }
		public VistrliteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vistrliteral; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVistrliteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VistrliteralContext vistrliteral() {
		VistrliteralContext _localctx = new VistrliteralContext(Context, State);
		EnterRule(_localctx, 46, RULE_vistrliteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 248; _localctx.val = Match(VISTRLITERAL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VistrinterContext : ParserRuleContext {
		public EContext val;
		public ITerminalNode VISTRINTERSTA() { return GetToken(ExpressionParser.VISTRINTERSTA, 0); }
		public ITerminalNode ISTRINTEREND() { return GetToken(ExpressionParser.ISTRINTEREND, 0); }
		public EContext e() {
			return GetRuleContext<EContext>(0);
		}
		public VistrinterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vistrinter; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IExpressionParserVisitor<TResult> typedVisitor = visitor as IExpressionParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVistrinter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VistrinterContext vistrinter() {
		VistrinterContext _localctx = new VistrinterContext(Context, State);
		EnterRule(_localctx, 48, RULE_vistrinter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250; Match(VISTRINTERSTA);
			State = 251; _localctx.val = e(0);
			State = 252; Match(ISTRINTEREND);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 2: return e_sempred((EContext)_localctx, predIndex);
		case 4: return units_sempred((UnitsContext)_localctx, predIndex);
		}
		return true;
	}
	private bool e_sempred(EContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 19);
		case 1: return Precpred(Context, 16);
		case 2: return Precpred(Context, 15);
		case 3: return Precpred(Context, 14);
		case 4: return Precpred(Context, 13);
		case 5: return Precpred(Context, 12);
		case 6: return Precpred(Context, 11);
		case 7: return Precpred(Context, 10);
		case 8: return Precpred(Context, 9);
		case 9: return Precpred(Context, 8);
		case 10: return Precpred(Context, 7);
		case 11: return Precpred(Context, 6);
		case 12: return Precpred(Context, 5);
		case 13: return Precpred(Context, 3);
		case 14: return Precpred(Context, 20);
		case 15: return Precpred(Context, 4);
		}
		return true;
	}
	private bool units_sempred(UnitsContext _localctx, int predIndex) {
		switch (predIndex) {
		case 16: return Precpred(Context, 3);
		case 17: return Precpred(Context, 4);
		}
		return true;
	}

	private static string _serializedATN = _serializeATN();
	private static string _serializeATN()
	{
	    StringBuilder sb = new StringBuilder();
	    sb.Append("\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\x37");
		sb.Append("\x101\x4\x2\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6");
		sb.Append("\x4\a\t\a\x4\b\t\b\x4\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r");
		sb.Append("\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t\x10\x4\x11\t\x11\x4\x12");
		sb.Append("\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15\x4\x16\t\x16\x4");
		sb.Append("\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x3\x2\x5\x2");
		sb.Append("\x36\n\x2\x3\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\x5\x3>\n\x3\x3");
		sb.Append("\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\a\x4\x46\n\x4\f\x4\xE\x4I");
		sb.Append("\v\x4\x5\x4K\n\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4");
		sb.Append("\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x5\x4Y\n\x4\x3\x4\x3\x4\x3\x4");
		sb.Append("\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4");
		sb.Append("\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4");
		sb.Append("\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4");
		sb.Append("\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4");
		sb.Append("\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\a\x4\x8D\n\x4\f\x4");
		sb.Append("\xE\x4\x90\v\x4\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5\x96\n\x5\x3\x5");
		sb.Append("\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5\x9F\n\x5\x3\x6\x3");
		sb.Append("\x6\x3\x6\x3\x6\x3\x6\x3\x6\x5\x6\xA7\n\x6\x3\x6\x3\x6\x3\x6");
		sb.Append("\x3\x6\x3\x6\x3\x6\a\x6\xAF\n\x6\f\x6\xE\x6\xB2\v\x6\x3\a\x3");
		sb.Append("\a\x3\b\x3\b\x3\b\x3\b\x3\t\x3\t\x3\t\a\t\xBD\n\t\f\t\xE\t\xC0");
		sb.Append("\v\t\x3\n\x3\n\x3\v\x3\v\x3\f\x3\f\x3\r\x3\r\x3\r\x3\r\x3\xE");
		sb.Append("\x3\xE\a\xE\xCE\n\xE\f\xE\xE\xE\xD1\v\xE\x3\xF\x3\xF\x3\x10");
		sb.Append("\x3\x10\x3\x11\x3\x11\x3\x11\x3\x11\x3\x12\x3\x12\x3\x12\x3");
		sb.Append("\x12\x3\x12\a\x12\xE0\n\x12\f\x12\xE\x12\xE3\v\x12\x3\x13\x3");
		sb.Append("\x13\x3\x14\x3\x14\x3\x15\x3\x15\x3\x15\x3\x15\x3\x16\x3\x16");
		sb.Append("\x3\x16\x3\x16\x3\x17\x3\x17\x3\x17\a\x17\xF4\n\x17\f\x17\xE");
		sb.Append("\x17\xF7\v\x17\x3\x18\x3\x18\x3\x19\x3\x19\x3\x1A\x3\x1A\x3");
		sb.Append("\x1A\x3\x1A\x3\x1A\x2\x4\x6\n\x1B\x2\x4\x6\b\n\f\xE\x10\x12");
		sb.Append("\x14\x16\x18\x1A\x1C\x1E \"$&(*,.\x30\x32\x2\x5\x4\x2\t\xE\x11");
		sb.Append("\x16\x5\x2\b\b\v\v\x10\x10\x6\x2\a\a\x1A\x1A\x1F!%&\x11B\x2");
		sb.Append("\x35\x3\x2\x2\x2\x4=\x3\x2\x2\x2\x6X\x3\x2\x2\x2\b\x9E\x3\x2");
		sb.Append("\x2\x2\n\xA6\x3\x2\x2\x2\f\xB3\x3\x2\x2\x2\xE\xB5\x3\x2\x2\x2");
		sb.Append("\x10\xBE\x3\x2\x2\x2\x12\xC1\x3\x2\x2\x2\x14\xC3\x3\x2\x2\x2");
		sb.Append("\x16\xC5\x3\x2\x2\x2\x18\xC7\x3\x2\x2\x2\x1A\xCF\x3\x2\x2\x2");
		sb.Append("\x1C\xD2\x3\x2\x2\x2\x1E\xD4\x3\x2\x2\x2 \xD6\x3\x2\x2\x2\"");
		sb.Append("\xE1\x3\x2\x2\x2$\xE4\x3\x2\x2\x2&\xE6\x3\x2\x2\x2(\xE8\x3\x2");
		sb.Append("\x2\x2*\xEC\x3\x2\x2\x2,\xF5\x3\x2\x2\x2.\xF8\x3\x2\x2\x2\x30");
		sb.Append("\xFA\x3\x2\x2\x2\x32\xFC\x3\x2\x2\x2\x34\x36\a\x3\x2\x2\x35");
		sb.Append("\x34\x3\x2\x2\x2\x35\x36\x3\x2\x2\x2\x36\x37\x3\x2\x2\x2\x37");
		sb.Append("\x38\x5\x4\x3\x2\x38\x39\a\x2\x2\x3\x39\x3\x3\x2\x2\x2:>\x5");
		sb.Append("\x6\x4\x2;>\t\x2\x2\x2<>\x3\x2\x2\x2=:\x3\x2\x2\x2=;\x3\x2\x2");
		sb.Append("\x2=<\x3\x2\x2\x2>\x5\x3\x2\x2\x2?@\b\x4\x1\x2@\x41\a\a\x2\x2");
		sb.Append("\x41J\a\x4\x2\x2\x42G\x5\x6\x4\x2\x43\x44\a\x6\x2\x2\x44\x46");
		sb.Append("\x5\x6\x4\x2\x45\x43\x3\x2\x2\x2\x46I\x3\x2\x2\x2G\x45\x3\x2");
		sb.Append("\x2\x2GH\x3\x2\x2\x2HK\x3\x2\x2\x2IG\x3\x2\x2\x2J\x42\x3\x2");
		sb.Append("\x2\x2JK\x3\x2\x2\x2KL\x3\x2\x2\x2LY\a\x5\x2\x2MN\a\x4\x2\x2");
		sb.Append("NO\x5\x6\x4\x2OP\a\x5\x2\x2PY\x3\x2\x2\x2QR\t\x3\x2\x2RY\x5");
		sb.Append("\x6\x4\x14ST\x5\b\x5\x2TU\a\b\x2\x2UY\x3\x2\x2\x2VY\a\x1A\x2");
		sb.Append("\x2WY\x5\b\x5\x2X?\x3\x2\x2\x2XM\x3\x2\x2\x2XQ\x3\x2\x2\x2X");
		sb.Append("S\x3\x2\x2\x2XV\x3\x2\x2\x2XW\x3\x2\x2\x2Y\x8E\x3\x2\x2\x2Z");
		sb.Append("[\f\x15\x2\x2[\\\a\x19\x2\x2\\\x8D\x5\x6\x4\x16]^\f\x12\x2\x2");
		sb.Append("^_\a\t\x2\x2_\x8D\x5\x6\x4\x13`\x61\f\x11\x2\x2\x61\x62\a\n");
		sb.Append("\x2\x2\x62\x8D\x5\x6\x4\x12\x63\x64\f\x10\x2\x2\x64\x65\a\v");
		sb.Append("\x2\x2\x65\x8D\x5\x6\x4\x11\x66g\f\xF\x2\x2gh\a\f\x2\x2h\x8D");
		sb.Append("\x5\x6\x4\x10ij\f\xE\x2\x2jk\a\xE\x2\x2k\x8D\x5\x6\x4\xFlm\f");
		sb.Append("\r\x2\x2mn\a\r\x2\x2n\x8D\x5\x6\x4\xEop\f\f\x2\x2pq\a\x11\x2");
		sb.Append("\x2q\x8D\x5\x6\x4\rrs\f\v\x2\x2st\a\x12\x2\x2t\x8D\x5\x6\x4");
		sb.Append("\fuv\f\n\x2\x2vw\a\x13\x2\x2w\x8D\x5\x6\x4\vxy\f\t\x2\x2yz\a");
		sb.Append("\x14\x2\x2z\x8D\x5\x6\x4\n{|\f\b\x2\x2|}\a\x15\x2\x2}\x8D\x5");
		sb.Append("\x6\x4\t~\x7F\f\a\x2\x2\x7F\x80\a\x16\x2\x2\x80\x8D\x5\x6\x4");
		sb.Append("\b\x81\x82\f\x5\x2\x2\x82\x83\a\x17\x2\x2\x83\x84\x5\x6\x4\x2");
		sb.Append("\x84\x85\a\x18\x2\x2\x85\x86\x5\x6\x4\x6\x86\x8D\x3\x2\x2\x2");
		sb.Append("\x87\x88\f\x16\x2\x2\x88\x8D\x5\n\x6\x2\x89\x8A\f\x6\x2\x2\x8A");
		sb.Append("\x8B\a\xF\x2\x2\x8B\x8D\x5\n\x6\x2\x8CZ\x3\x2\x2\x2\x8C]\x3");
		sb.Append("\x2\x2\x2\x8C`\x3\x2\x2\x2\x8C\x63\x3\x2\x2\x2\x8C\x66\x3\x2");
		sb.Append("\x2\x2\x8Ci\x3\x2\x2\x2\x8Cl\x3\x2\x2\x2\x8Co\x3\x2\x2\x2\x8C");
		sb.Append("r\x3\x2\x2\x2\x8Cu\x3\x2\x2\x2\x8Cx\x3\x2\x2\x2\x8C{\x3\x2\x2");
		sb.Append("\x2\x8C~\x3\x2\x2\x2\x8C\x81\x3\x2\x2\x2\x8C\x87\x3\x2\x2\x2");
		sb.Append("\x8C\x89\x3\x2\x2\x2\x8D\x90\x3\x2\x2\x2\x8E\x8C\x3\x2\x2\x2");
		sb.Append("\x8E\x8F\x3\x2\x2\x2\x8F\a\x3\x2\x2\x2\x90\x8E\x3\x2\x2\x2\x91");
		sb.Append("\x96\x5\xE\b\x2\x92\x96\x5\x18\r\x2\x93\x96\x5 \x11\x2\x94\x96");
		sb.Append("\x5*\x16\x2\x95\x91\x3\x2\x2\x2\x95\x92\x3\x2\x2\x2\x95\x93");
		sb.Append("\x3\x2\x2\x2\x95\x94\x3\x2\x2\x2\x96\x9F\x3\x2\x2\x2\x97\x9F");
		sb.Append("\a\x1F\x2\x2\x98\x9F\a \x2\x2\x99\x9F\a!\x2\x2\x9A\x9F\a\"\x2");
		sb.Append("\x2\x9B\x9F\a#\x2\x2\x9C\x9F\a$\x2\x2\x9D\x9F\a%\x2\x2\x9E\x95");
		sb.Append("\x3\x2\x2\x2\x9E\x97\x3\x2\x2\x2\x9E\x98\x3\x2\x2\x2\x9E\x99");
		sb.Append("\x3\x2\x2\x2\x9E\x9A\x3\x2\x2\x2\x9E\x9B\x3\x2\x2\x2\x9E\x9C");
		sb.Append("\x3\x2\x2\x2\x9E\x9D\x3\x2\x2\x2\x9F\t\x3\x2\x2\x2\xA0\xA1\b");
		sb.Append("\x6\x1\x2\xA1\xA2\a\x4\x2\x2\xA2\xA3\x5\n\x6\x2\xA3\xA4\a\x5");
		sb.Append("\x2\x2\xA4\xA7\x3\x2\x2\x2\xA5\xA7\x5\f\a\x2\xA6\xA0\x3\x2\x2");
		sb.Append("\x2\xA6\xA5\x3\x2\x2\x2\xA7\xB0\x3\x2\x2\x2\xA8\xA9\f\x5\x2");
		sb.Append("\x2\xA9\xAA\a\n\x2\x2\xAA\xAF\x5\n\x6\x6\xAB\xAC\f\x6\x2\x2");
		sb.Append("\xAC\xAD\a\t\x2\x2\xAD\xAF\a\"\x2\x2\xAE\xA8\x3\x2\x2\x2\xAE");
		sb.Append("\xAB\x3\x2\x2\x2\xAF\xB2\x3\x2\x2\x2\xB0\xAE\x3\x2\x2\x2\xB0");
		sb.Append("\xB1\x3\x2\x2\x2\xB1\v\x3\x2\x2\x2\xB2\xB0\x3\x2\x2\x2\xB3\xB4");
		sb.Append("\t\x4\x2\x2\xB4\r\x3\x2\x2\x2\xB5\xB6\a\x1B\x2\x2\xB6\xB7\x5");
		sb.Append("\x10\t\x2\xB7\xB8\a,\x2\x2\xB8\xF\x3\x2\x2\x2\xB9\xBD\x5\x12");
		sb.Append("\n\x2\xBA\xBD\x5\x14\v\x2\xBB\xBD\x5\x16\f\x2\xBC\xB9\x3\x2");
		sb.Append("\x2\x2\xBC\xBA\x3\x2\x2\x2\xBC\xBB\x3\x2\x2\x2\xBD\xC0\x3\x2");
		sb.Append("\x2\x2\xBE\xBC\x3\x2\x2\x2\xBE\xBF\x3\x2\x2\x2\xBF\x11\x3\x2");
		sb.Append("\x2\x2\xC0\xBE\x3\x2\x2\x2\xC1\xC2\a)\x2\x2\xC2\x13\x3\x2\x2");
		sb.Append("\x2\xC3\xC4\a*\x2\x2\xC4\x15\x3\x2\x2\x2\xC5\xC6\a+\x2\x2\xC6");
		sb.Append("\x17\x3\x2\x2\x2\xC7\xC8\a\x1C\x2\x2\xC8\xC9\x5\x1A\xE\x2\xC9");
		sb.Append("\xCA\a/\x2\x2\xCA\x19\x3\x2\x2\x2\xCB\xCE\x5\x1C\xF\x2\xCC\xCE");
		sb.Append("\x5\x1E\x10\x2\xCD\xCB\x3\x2\x2\x2\xCD\xCC\x3\x2\x2\x2\xCE\xD1");
		sb.Append("\x3\x2\x2\x2\xCF\xCD\x3\x2\x2\x2\xCF\xD0\x3\x2\x2\x2\xD0\x1B");
		sb.Append("\x3\x2\x2\x2\xD1\xCF\x3\x2\x2\x2\xD2\xD3\a-\x2\x2\xD3\x1D\x3");
		sb.Append("\x2\x2\x2\xD4\xD5\a.\x2\x2\xD5\x1F\x3\x2\x2\x2\xD6\xD7\a\x1D");
		sb.Append("\x2\x2\xD7\xD8\x5\"\x12\x2\xD8\xD9\a\x33\x2\x2\xD9!\x3\x2\x2");
		sb.Append("\x2\xDA\xE0\x5$\x13\x2\xDB\xE0\x5\x14\v\x2\xDC\xE0\x5\x16\f");
		sb.Append("\x2\xDD\xE0\x5&\x14\x2\xDE\xE0\x5(\x15\x2\xDF\xDA\x3\x2\x2\x2");
		sb.Append("\xDF\xDB\x3\x2\x2\x2\xDF\xDC\x3\x2\x2\x2\xDF\xDD\x3\x2\x2\x2");
		sb.Append("\xDF\xDE\x3\x2\x2\x2\xE0\xE3\x3\x2\x2\x2\xE1\xDF\x3\x2\x2\x2");
		sb.Append("\xE1\xE2\x3\x2\x2\x2\xE2#\x3\x2\x2\x2\xE3\xE1\x3\x2\x2\x2\xE4");
		sb.Append("\xE5\a\x30\x2\x2\xE5%\x3\x2\x2\x2\xE6\xE7\a\x31\x2\x2\xE7\'");
		sb.Append("\x3\x2\x2\x2\xE8\xE9\a\x32\x2\x2\xE9\xEA\x5\x6\x4\x2\xEA\xEB");
		sb.Append("\a(\x2\x2\xEB)\x3\x2\x2\x2\xEC\xED\a\x1E\x2\x2\xED\xEE\x5,\x17");
		sb.Append("\x2\xEE\xEF\a\x37\x2\x2\xEF+\x3\x2\x2\x2\xF0\xF4\x5.\x18\x2");
		sb.Append("\xF1\xF4\x5\x30\x19\x2\xF2\xF4\x5\x32\x1A\x2\xF3\xF0\x3\x2\x2");
		sb.Append("\x2\xF3\xF1\x3\x2\x2\x2\xF3\xF2\x3\x2\x2\x2\xF4\xF7\x3\x2\x2");
		sb.Append("\x2\xF5\xF3\x3\x2\x2\x2\xF5\xF6\x3\x2\x2\x2\xF6-\x3\x2\x2\x2");
		sb.Append("\xF7\xF5\x3\x2\x2\x2\xF8\xF9\a\x34\x2\x2\xF9/\x3\x2\x2\x2\xFA");
		sb.Append("\xFB\a\x35\x2\x2\xFB\x31\x3\x2\x2\x2\xFC\xFD\a\x36\x2\x2\xFD");
		sb.Append("\xFE\x5\x6\x4\x2\xFE\xFF\a(\x2\x2\xFF\x33\x3\x2\x2\x2\x16\x35");
		sb.Append("=GJX\x8C\x8E\x95\x9E\xA6\xAE\xB0\xBC\xBE\xCD\xCF\xDF\xE1\xF3");
		sb.Append("\xF5");
	    return sb.ToString();
	}

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace NeoEdit.Common.Expressions.Parser
